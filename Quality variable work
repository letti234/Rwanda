var geometry = ee.FeatureCollection("FAO/GAUL/2015/level0")
.filter(ee.Filter.eq("ADM0_NAME", "Rwanda"));

//Open MODIS data and clip to geometry

var data = ee.ImageCollection('MODIS/006/MOD44B')
.map(function(image){return image.clip(geometry)});

print(data, "MODIS image clipped to Rwanda bounding box");

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//Quality variable
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

//Quality is stored in 8 "bits" for each pixel, but the value is reported as numeric. Each numeric
//value from 0 to 255 is a combination of eight binary indicators.

//MODIS states any quality binary value with 2 or more 1's is potentially "bad"
//See https://lpdaac.usgs.gov/documents/459/MOD44B_User_Guide_V5.pdf

//Subset data
var quality00 = data.filter(ee.Filter.date('2000-01-01', '2000-12-31'))
.select("Quality").toBands();


print(quality00, "Image quality assessment 2000");

//Note that this map isn't helpful since  the values cannot be interpreted on a continuous scale. 
//For example, high values represent 1's in the 6th-8th bit.

Map.addLayer(quality00,  {min: 0, max: 255, palette: ['white', 'red']}, "Raw image quality indicators");


/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Mapping "bad" pixels: >2 1's. From ChatGPT.
//
////////////////////////////////////////////////////////////////////////////////////////////////

//This is likely wrong - chatGP added this rightShift step to remove 2 of the bits.

// Define a function to identify "bad" pixels
var identifyBadPixels = function(image) {
  // Use the right shift operator (>>) to shift the bits yto the least significant bits
  var shiftedImage = image.rightShift(2); // Shift by 2 bits
  
  // Use the modulo operator (%) to check if the remainder is greater than or equal to 2
  var badPixelMask = shiftedImage.mod(4).gte(2);
  
  // Return the mask
  return badPixelMask;
};

// Apply the function to your image
var badPixelMask = identifyBadPixels(quality00);

// Display the "bad" pixels on the map
Map.addLayer(badPixelMask, {}, 'Bad Pixels (ChatGPT');



/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Mapping "bad" pixels: >2 1's. From user blog - https://spatialthoughts.com/2021/08/19/qa-bands-bitmasks-gee/
//
////////////////////////////////////////////////////////////////////////////////////////////////
//Probably more accurate than the ChatGPT version. I still want a map with the counts of 1's across
//the 8-bit object.


// Helper function to extract the values from specific bits

var bitwiseExtract = function(input, fromBit, toBit) {
  var maskSize = ee.Number(1).add(toBit).subtract(fromBit)
  var mask = ee.Number(1).leftShift(maskSize).subtract(1)
  return input.rightShift(fromBit).bitwiseAnd(mask)
}


var qualMask00 = bitwiseExtract(quality00, 0, 8).lte(1);
print(qualMask00);
Map.addLayer(qualMask00, {min: 0, max: 1, palette: ['white', 'red']} , "Bad pixel classification");


//This is certainly a more stringent criteria. But I would prefer to export the pixel's number of 1's!




/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Counting number of bad bits - from ChatGPT
//
////////////////////////////////////////////////////////////////////////////////////////////////




